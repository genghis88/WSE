package edu.nyu.cs.cs2580;

import java.util.Scanner;
import java.util.Vector;

public class LinearRanker extends Ranker {
  private double beta_cos = 0.25;
  private double beta_ql = 0.25;
  private double beta_phrase = 0.25;
  private double beta_numviews = 0.25;
  
  public LinearRanker(String index_source) {
    super(index_source);
  }
  
  public ScoredDocument runquery(String query, int did){
    // Build query vector
    Scanner s = new Scanner(query);
    Vector < String > qv = new Vector < String > ();
    while (s.hasNext()){
      String term = s.next();
      qv.add(term);
    }

    // Get the document vector. For hw1, you don't have to worry about the
    // details of how index works.
    Document d = super.get_index().getDoc(did);
    Vector < String > dv = d.get_body_vector();

    // Score the document. Here we have provided a very simple ranking model,
    // where a document is scored 1.0 if it gets hit by at least one query term.
    double score = 0.0;
    for (int j = 0; j < qv.size(); ++j){
      boolean occurs = false;
      for (int i = 0; i < dv.size(); ++i){
        if (dv.get(i).equals(qv.get(j))){
          occurs = true;
          break;
        }
      }
      if (occurs){
        System.out.println("lambda: "+lambda+" doc term freq "+d.docTermFrequency(qv.get(j))+" words in doc: "+d.docTermFrequency()+" term frequency "+d.termFrequency(qv.get(j))+" all words "+d.termFrequency());
        score = score + (1 - lambda) * d.docTermFrequency(qv.get(j)) / d.docTermFrequency() + lambda * d.termFrequency(qv.get(j)) / d.termFrequency();
      }
      else {
        score = score + lambda * d.termFrequency(qv.get(j)) / d.termFrequency();
      }
    }
    score = Math.log1p(score)/Math.log(2);
    return new ScoredDocument(did, d.get_title_string(), score);
  }
}
